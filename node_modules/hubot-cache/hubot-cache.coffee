# class HubotCache
#   conversations: {}
#   
#   constructor: (@robot) ->
#     @robot.brain.on 'loaded', =>
#       @robot.brain.data.conversations ?= {}
#       @conversations = @robot.brain.data.conversations
#   
#   startConversation: (room, username) ->
#     unless @conversations[room]?
#       @conversations[room] = {}
# 
#     unless @conversations[room][username]?
#       @conversations[room][username] = new Conversation()

class Conversation
  constructor: (@robot, @keep) ->
    @robot.brain.on 'loaded', =>
    @cache = @robot.brain.data.conversation || {}

  add: (message) ->
    unless @cache[message.room]?
      @cache[message.room] = {}
    
    unless @cache[message.room][message.name]?
      @cache[message.room][message.name] = []

    @cache[message.room][message.name].unshift message
    while @cache[message.room][message.name].length > @keep
      @cache[message.room][message.name].pop()
    @robot.brain.data.conversation = @cache
#
#   show: (lines) ->
#     if (lines > @cache.length)
#       lines = @cache.length
#     reply = 'Showing ' + lines + ' lines of conversation:\n'
#     reply = reply + @entryToString(message) + '\n' for message in @cache[-lines..]
#     return reply

  entryToString: (event) ->
    return "[#{event.hours}:#{event.minutes}] #{event.room} #{event.name}: #{event.message}"

  lastEntry: (room, name, offset = 0) ->
    unless @cache[room]?
      return false
    
    unless @cache[room][name]?
      return false
    
    unless @cache[room][name][offset]?
      return false
    else
      return @cache[room][name][offset]

  clear: ->
    @robot.brain.data.conversation = {}

class ConversationEntry
  constructor: (@msg) ->
    @name = @msg.message.user.name
    @room = @msg.message.user.room
    @text = @msg.message.text.replace(new RegExp("#{@msg.robot.name} ?", 'i'), '')
    @time = new Date()
    @hours = @time.getHours()
    @minutes = @time.getMinutes()
    @response = []
    if @minutes < 10
      @minutes = '0' + @minutes


module.exports = {
  Conversation
  ConversationEntry
}